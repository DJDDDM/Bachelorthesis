#!/usr/bin/python

import pdb
import sys

#Dictionary


from decimal import *

dictionary={}

with open ("FCIDUMP") as f:
   for dummy in xrange(4):
     next(f)
   for line in f:
     integral = float(line.split()[0])   #I_iiii
     first= [line.split()[1], line.split()[2], line.split()[3], line.split()[4]]    #(I_)ijkl
     indizes=[int(first[0]), int(first[1]),int(first[2]), int(first[3])]
     dictionary[(indizes[0]), (indizes[1]), (indizes[2]), (indizes[3])] = integral

#for key,value in dictionary.iteritems(): print key,value


# G-Matrix

NORB = 13   #Number of Basisfunctions

import numpy
G = numpy.zeros((NORB+1, NORB+1))
P = numpy.eye(NORB+1, dtype= float)
my = 1
ny = 1
si = 1
la = 1
G[my,ny]=1

#pdb.set_trace()

for my in range (1, NORB+1):
  for ny in range (1, my+1):
    G[my, ny]=0
    for la in range (1, NORB+1):
      for si in range (1, la):
        print ('my,ny,la,si',my,ny,la,si,)
        if my>=la and ny>=si:
          G[my,ny]+=2*P[la,si]*dictionary[my,ny,la,si]
          G[my,ny]+=(-1)*P[la,si]*dictionary[my,la,ny,si]
        elif my==la and ny<=si:
          G[my,ny]+=2*P[la,si]*dictionary[la,si,my,ny]
          G[my,ny]+=(-1)*P[la,si]*dictionary[my,la,si,ny]
        elif my>la and ny<=si:
          G[my,ny]+=2*P[la,si]*dictionary[my,ny,la,si]
          G[my,ny]+=(-1)*P[la,si]*dictionary[my,la,si,ny]
        elif my<=la and ny>=si:
          G[my,ny]+=2*P[la,si]*dictionary[la,si,my,ny]
          G[my,ny]+=(-1)*P[la,si]*dictionary[la,my,ny,si]
        elif my<=la and ny<=si:
          G[my,ny]+=2*P[la,si]*dictionary[la, si, my,ny]
          G[my,ny]+=(-1)*P[la,si]*dictionary[la,my,si,ny]
        else:
          print ('error')
      si=la
      print ('my,ny,la,la',my,ny,la,si,)
      if my>=la and ny>=si:
        G[my,ny]+=1*P[la,si]*dictionary[my,ny,la,si]
        G[my,ny]+=(-0.5)*P[la,si]*dictionary[my,la,ny,si]
      elif my<=la and ny<=si:
        G[my,ny]+=1*P[la,si]*dictionary[la, si, my,ny]
        G[my,ny]+=(-0.5)*P[la,si]*dictionary[la,my,si,ny]
      elif my>=la and ny<=si:
        G[my,ny]+=1*P[la,si]*dictionary[my,ny,la,si]
        G[my,ny]+=(-0.5)*P[la,si]*dictionary[my,la,si,ny]
      elif my<=la and ny>=si:
        G[my,ny]+=1*P[la,si]*dictionary[la,si,my,ny]
        G[my,ny]+=(-0.5)*P[la,si]*dictionary[la,my,ny,si]
      else:
        print ('error')

for ny in range (1, NORB+1):    #mirror the offdiagonals
  for my in range (1, ny):
    G[my,ny]=G[ny,my]

print G
