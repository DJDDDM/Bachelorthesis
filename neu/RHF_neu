#!/usr/bin/python3
import numpy
import sys
import f90nml
import os

def main():
    global NORB, NELEC, E_nucc 
    NORB, NELEC, E_nucc, H, twomatrix, nml = init()
    NELEC+=int(sys.argv[3])
    if NELEC%2==0:
        NOCC=int(NELEC/2)
    else:
        print('odd')
        sys.exit()
    E_old=0
    iters=1
    print('NORB=',NORB,'NELEC=',NELEC,'NOCC=',NOCC,'E_nucc=',E_nucc)
    P=numpy.zeros((NORB,NORB))
    for a in range(NOCC):
        P[a,a]=1
    
    diis=diis_class(NORB)
    dodiis=int(sys.argv[2])

    while True:
    
        #P->F
        F=numpy.subtract(numpy.add(H,numpy.tensordot(numpy.multiply(2,P),twomatrix,((0,1),(3,2)))),numpy.tensordot(P,twomatrix,((0,1),(1,2))))
        #energy
        E=numpy.add(E_nucc,numpy.tensordot(P,numpy.add(H,F),((0,1),(1,0))))
        #DIIS
        if dodiis==1:
            F=diis.diis_func(F,P,E,iters)
        #F->C
        vals, C = numpy.linalg.eig(F)
        idx = vals.argsort()[::1]
        vals=vals[idx]
        C=C[:,idx]
        #C->P
        P=numpy.matmul(C[:,:NOCC],numpy.transpose(C[:,:NOCC]))
        #loopcontrol
        print('iters',iters,'Energy',E)
        if abs(E-E_old)<10**-7: break
        if iters > 1000:
            print('not converged after', iters ,'iterations')
            break
        E_old=E
        iters+=1
    
    print('finished calculation')
    #fcimaker(NORB, Ca, Cb, twomatrix,H,nml)
    print('skipped newFCIDUMP')
    print('Done')

class diis_class:
    def __init__(self,NORB):
        self.diisiters=0
        self.maxdiis=5
        self.diis_error_matrices= numpy.zeros((self.maxdiis, NORB, NORB))
        self.diis_fock_matrices= numpy.zeros_like(self.diis_error_matrices)
        self.diis_energy=numpy.zeros((self.maxdiis))

    def diis_func(self,fock, dens, energy, iters):
        """ Extrapolate new fock matrix based on input fock matrix
            and previous fock-matrices.
            Arguments:
            fock -- current fock matrix
            Returns:
            (fock, error) -- interpolated fock matrix and diis-error
        """
        diis_fock = numpy.zeros_like(fock)
    
        # copy data down to lower storage
        for k in reversed(range(1, min(iters, self.maxdiis))):
            self.diis_error_matrices[k] = self.diis_error_matrices[k-1][:]
            self.diis_fock_matrices[k] = self.diis_fock_matrices[k-1][:]
            self.diis_energy[k] = self.diis_energy[k-1]
    
        # calculate error matrix
        error_mat  = numpy.dot(fock, dens)
        error_mat -= error_mat.T
    
    
        # put data in storage
        self.diis_error_matrices[0]  = error_mat
        self.diis_fock_matrices[0] = fock[:]
        self.diis_energy[0] = energy
    
        #determine wether you go EDIIS or CDIIS
        e_max=error_mat.max()
        e_min=error_mat.min()
        #print('e_max',e_max, 'e_min',e_min)
        if e_max < 10**-6 and e_min > -10**-6 : #if really small then dont do DIIS
            print('noDIIS')
            return fock
        #EDIIS
        if e_max > 0.01 or e_min < -0.01 : #if big then do EDIIS
            print('EDIIS')
            #bmat
            bsize = min(iters, self.maxdiis)
            bmat = -1.0*numpy.ones((bsize+1,bsize+1))
            bmat[bsize, bsize] = 0
            for b1 in range(bsize):
                for b2 in range(bsize):
                    bmat[b1, b2] = numpy.trace(self.diis_error_matrices[b1].dot(self.diis_error_matrices[b2]))
            #rhs
            rhs = numpy.zeros(bsize+1)
            rhs[bsize] = -1
            for a in range(bsize):
                rhs[a]=self.diis_energy[a]
            while True:
                #solve
                C =  numpy.linalg.solve(bmat, rhs)
                #remove C_i<0
                if C[:-1].min() < 0:
                    i=numpy.argmin(C)
                    bmat=numpy.delete(bmat,i,0)
                    bmat=numpy.delete(bmat,i,1)
                    rhs=numpy.delete(rhs,i,0)
                    if len(rhs)==1: #no C_i<0 found
                        return fock
                    continue 
                break

            # form new interpolated diis fock matrix with non0 C_i
            for i, k in enumerate(C[:-1]):
                diis_fock += k*self.diis_fock_matrices[i]

            return diis_fock
        #CDIIS
        else:   #if not big then do CDIIS
            print('CDIIS')
            self.diisiters+=1
            bsize = min(self.diisiters, self.maxdiis)
            bmat = -1.0*numpy.ones((bsize+1,bsize+1))
            rhs = numpy.zeros(bsize+1)
            bmat[bsize, bsize] = 0
            rhs[bsize] = -1
            for b1 in range(bsize):
                for b2 in range(bsize):
                    bmat[b1, b2] = numpy.trace(self.diis_error_matrices[b1].dot(self.diis_error_matrices[b2]))
            C =  numpy.linalg.solve(bmat, rhs)

            # form new interpolated diis fock matrix
            for i, k in enumerate(C[:-1]):
                diis_fock += k*self.diis_fock_matrices[i]

            return diis_fock


def fcimaker(NORB, Ca, Cb, twomatrix,H,nml):
    MO_a=numpy.tensordot(Ca,numpy.tensordot(Ca,numpy.tensordot(Ca,numpy.tensordot(Ca,twomatrix,((0),(3))),((0),(2))),((0),(1))),((0),(0)))
    MO_b=numpy.tensordot(Cb,numpy.tensordot(Cb,numpy.tensordot(Cb,numpy.tensordot(Cb,twomatrix,((0),(3))),((0),(2))),((0),(1))),((0),(0)))
    H_MO=numpy.tensordot(Cb,numpy.tensordot(Cb,H,((0),(1))),((0),(0)))+numpy.tensordot(Cb,numpy.tensordot(Cb,H,((0),(1))),((0),(0)))
    fcidump = open(sys.argv[2], 'w')
    nml.write(fcidump)
    for I in range(1, NORB + 1):
        for J in range(1, I + 1):
            for K in range(1, I + 1):
                for L in range(1, K + 1):
                    if(I == K and J < L):
                            continue
                    fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(MO_a[I-1,J-1,K-1,L-1], I, J, K, L))
                    fcidump.write('\n')
    fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(0000000000000000, 0, 0, 0, 0))
    fcidump.write('\n')
    for I in range(1, NORB + 1):
        for J in range(1, I + 1):
            for K in range(1, I + 1):
                for L in range(1, K + 1):
                    if(I == K and J < L):
                            continue
                    fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(MO_b[I-1,J-1,K-1,L-1], I, J, K, L))
                    fcidump.write('\n')
    for I in range(1, NORB + 1):
        for J in range(1, I + 1):
            fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(H_MO[I-1,J-1], I, J, 0, 0))
            fcidump.write('\n')
    fcidump.write('{0:23.16E} {1:4d} {1:4d} {1:4d} {1:4d}'.format(E_nucc,0))
    fcidump.close()
    return

def init():
    with open(sys.argv[1],'r') as f:
        print('inputfile:',sys.argv[1])
        with open('tmpnml.tmp','w')as g:
            #find and copy nml
            while True:
                line = f.readline()
                g.write(line)
                if line.find('&END') != -1:
                    break
                if line.find(r'/') != -1:
                    break

        with open('tmpnml.tmp') as g:
            #read the nml
            nml = f90nml.read(g)
            NORB = nml['fci']['NORB']
            NELEC = nml['fci']['NELEC']
        os.remove('tmpnml.tmp')


        H = numpy.zeros((NORB, NORB))
        twomatrix = numpy.zeros((NORB, NORB, NORB, NORB))
        while True:
            line=f.readline()
            if line == '':break
            integral = numpy.float64(line.split()[0])
            my = int(line.split()[1])-1
            ny = int(line.split()[2])-1
            la = int(line.split()[3])-1
            si = int(line.split()[4])-1
            if my == ny == la == si == -1:
                E_nucc = integral
            if la == si == -1 and my != -1 and ny != -1:
                H[my,ny] = integral
                H[ny,my] = integral
            elif my != -1 and ny != -1 and la != -1 and si != -1 :
                twomatrix[my, ny, la, si] = integral
                twomatrix[ny, my, la, si] = integral
                twomatrix[my, ny, si, la] = integral
                twomatrix[ny, my, si, la] = integral
                twomatrix[la, si, my, ny] = integral
                twomatrix[si, la, my, ny] = integral
                twomatrix[la, si, ny, my] = integral
                twomatrix[si, la, ny, my] = integral
    return(NORB, NELEC, E_nucc, H, twomatrix, nml)

def outsqr(title, mat, width=15):
        frmt = ''.join(['{: > ', str(width), '.', str(max(width - 7, 0)),
                        'f}'])
        ifrmt = ''.join(['{:^', str(width), 'd}'])
        headline = ''.join([ifrmt.format(i) for i in range(len(mat) + 1)])
        outline = '\n'.join([''.join([ifrmt.format(i + 1),
                            ''.join([frmt.format(val) for val in row])]) for i,
                            row in enumerate(mat)])
        print('\n'.join([title, headline, outline]))

if __name__ == '__main__':
    main()
