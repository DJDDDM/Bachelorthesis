#!/usr/bin/python3
import numpy
import sys
import f90nml
import os

def main():
    global NORB, NELEC, E_nucc, NOCC

    #IandO
    #NORB, NELEC, E_nucc, H, twomatrix, nml = init()
    NORB, NELEC, E_nucc, AO_H, AO_twomatrix, nml = init_notall()
    NELEC+=int(sys.argv[3])
    if NELEC%2==0:
        NOCC=int(NELEC/2)
    else:
        print('odd')
        sys.exit()
    print('NORB=',NORB,'NELEC=',NELEC,'NOCC=',NOCC,'E_nucc=',E_nucc)

    #RHF
    RHF_dic = RHF().RHF_main(AO_twomatrix,AO_H)
    print('Done RHF','RHF_E=', RHF_dic['RHF_E'] )

    #Transformation
    MO_F = numpy.matmul(numpy.matmul(RHF_dic['RHF_C'].T,RHF_dic['RHF_F']),RHF_dic['RHF_C'])
    MO_twomatrix = twomatrix_transform(AO_twomatrix,RHF_dic['RHF_C'])

    #MP2
    E_MP2=MP2(MO_twomatrix,MO_F)
    print('E_MP2=',E_MP2)
    print('RHF_E+E_MP2=',RHF_dic['RHF_E']+E_MP2)
    #MP3
    E_MP3=MP3_class(MO_twomatrix,RHF_dic['RHF_vals']).E_MP3_func()
    print('E_MP3=',E_MP3)
    print('E_MP2+E_MP3=',E_MP2+E_MP3)
    print('RHF+MP2+MP3=',RHF_dic['RHF_E']+E_MP2+E_MP3)



class RHF:
    def __init__(self):
        self.E_old=0
        self.iters=1
        self.diis=diis_class(NORB)
        self.P=numpy.zeros((NORB,NORB))
        for a in range(NOCC):
            self.P[a,a]=1

    def RHF_main(self,twomatrix,H):
        while True:
            #P->F
            F=numpy.subtract(numpy.add(H,numpy.tensordot(numpy.multiply(2,self.P),twomatrix,((0,1),(3,2)))),numpy.tensordot(self.P,twomatrix,((0,1),(1,2))))
            #energy
            E=numpy.add(E_nucc,numpy.tensordot(self.P,numpy.add(H,F),((0,1),(1,0))))
            #DIIS
            F,e_abs=self.diis.diis_func(F,self.P,E,self.iters)
            #F->C
            vals, C = numpy.linalg.eig(F)
            idx = vals.argsort()[::1]
            vals=vals[idx]
            C=C[:,idx]
            #C->P
            self.P=numpy.matmul(C[:,:NOCC],numpy.transpose(C[:,:NOCC]))
            #loopcontrol
            print('iters',self.iters,'Energy',E)
            if e_abs < 10**-6: 
                print('iters',self.iters,'Energy',E,'e_abs=',e_abs)
                print('converged on DIIS')
                break
            if abs(E-self.E_old)<10**-7 and dodiis != 1: break
            if self.iters > 1000:
                print('not converged after', self.iters ,'iterations')
                break
            self.E_old=E
            self.iters+=1
        RHF_dic = {
                    "RHF_E" : E,
                    "RHF_P" : self.P,
                    "RHF_C" : C,
                    "RHF_vals" : vals,
                    "RHF_F" : F
                    }
        return RHF_dic

class MP3_class:
    def __init__(self,twomatrix,vals):
        #change twomatrix from chemiker to physiker notation
        self.twomatrix=numpy.swapaxes(twomatrix,1,2)
        #calculate sub_Matrix
        self.sub_Matrix = [(2*self.twomatrix[a,b,c,d]-self.twomatrix[a,b,d,c])
                            for a in range(NORB)
                            for b in range(NORB)
                            for c in range(NORB)
                            for d in range(NORB)
                            ]
        self.sub_Matrix = numpy.resize(self.sub_Matrix,(NORB,NORB,NORB,NORB))
        #get vals
        self.vals = vals

    def mult_func(self,a,b,c,d,r,s,t,u):
        return self.twomatrix[a,b,c,d]*self.twomatrix[r,s,t,u]+self.twomatrix[a,b,d,c]*self.twomatrix[r,s,u,t]

    def E1_func(self,a,b,c,d,r,s):
        s1 = self.sub_Matrix[r,s,d,c]*self.mult_func(a,b,r,s,c,d,b,a)
        s2 = self.sub_Matrix[r,s,c,d]*self.mult_func(a,b,r,s,c,d,a,b)
        m1 = self.vals[a]+self.vals[b]-self.vals[r]-self.vals[s]
        m2 = self.vals[c]+self.vals[d]-self.vals[r]-self.vals[s]
        E1 = (s1+s2)/(m1*m2)
        return E1

    def E2_func(self,a,b,r,s,t,u):
        s1 = self.sub_Matrix[r,s,u,t]*self.mult_func(a,b,r,s,t,u,b,a)
        s2 = self.sub_Matrix[r,s,t,u]*self.mult_func(a,b,r,s,t,u,a,b)
        m1 = self.vals[a]+self.vals[b]-self.vals[r]-self.vals[s]
        m2 = self.vals[a]+self.vals[b]-self.vals[t]-self.vals[u]
        E2 = (s1+s2)/(m1*m2)
        return E2

    def E3_func(self,a,b,c,r,s,t):
        s1 = self.twomatrix[c,s,t,b]*self.sub_Matrix[r,t,a,c]*self.sub_Matrix[a,b,r,s]
        s2 = self.twomatrix[c,s,b,t]*self.twomatrix[a,b,s,r]*self.sub_Matrix[r,t,c,a]
        s3 = self.twomatrix[c,s,b,t]*self.twomatrix[a,b,r,s]*self.sub_Matrix[r,t,a,c]
        m1 = self.vals[a]+self.vals[b]-self.vals[r]-self.vals[s]
        m2 = self.vals[a]+self.vals[c]-self.vals[r]-self.vals[t]
        E3 = (s1-s2-s3)/(m1*m2)
        return E3

    def E_MP3_func(self):
        E1 = [self.E1_func(a,b,c,d,r,s)
                for a in range(NOCC)
                for b in range(NOCC)
                for c in range(NOCC)
                for d in range(NOCC)
                for r in range(NOCC,NORB)
                for s in range(NOCC,NORB)
                ]
        E1 = numpy.sum(E1)
        E2 = [self.E2_func(a,b,r,s,t,u)
                for a in range(NOCC)
                for b in range(NOCC)
                for r in range(NOCC, NORB)
                for s in range(NOCC, NORB)
                for t in range(NOCC, NORB)
                for u in range(NOCC, NORB)
                ]
        E2 = numpy.sum(E2)
        E3 = [self.E3_func(a,b,c,r,s,t)
                for a in range(NOCC)
                for b in range(NOCC)
                for c in range(NOCC)
                for r in range(NOCC, NORB)
                for s in range(NOCC, NORB)
                for t in range(NOCC, NORB)
                ]
        E3 = numpy.sum(E3)
        E_MP3 = 0.25*E1+0.25*E2+2*E3
        return E_MP3

def twomatrix_transform(twomatrix, C):
    M=twomatrix
    M=numpy.tensordot(C.T,M,((0),(0)))
    M=numpy.tensordot(C.T,M,((0),(1)))
    M=numpy.tensordot(C,M,((0),(2)))
    M=numpy.tensordot(C,M,((0),(3)))
    return M

def MP2(twomatrix,F):
    E_MP2 = [(2*twomatrix[a,r,b,s]**2-twomatrix[a,r,b,s]*twomatrix[a,s,b,r])/(F[a,a]+F[b,b]-F[r,r]-F[s,s])
                for a in range(NOCC)
                for b in range(NOCC)
                for r in range(NOCC,NORB)
                for s in range(NOCC,NORB)
                ]
    E_MP2 = numpy.sum(E_MP2)
    return E_MP2




class diis_class:
    def __init__(self,NORB):
        self.diisiters=0
        self.maxdiis=5
        self.diis_error_matrices= numpy.zeros((self.maxdiis, NORB, NORB))
        self.diis_fock_matrices= numpy.zeros_like(self.diis_error_matrices)
        self.diis_energy=numpy.zeros((self.maxdiis))

    def diis_func(self,fock, dens, energy, iters):
        """ Extrapolate new fock matrix based on input fock matrix
            and previous fock-matrices.
            Arguments:
            fock -- current fock matrix
            Returns:
            (fock, error) -- interpolated fock matrix and diis-error
        """
        diis_fock = numpy.zeros_like(fock)
    
        # copy data down to lower storage
        for k in reversed(range(1, min(iters, self.maxdiis))):
            self.diis_error_matrices[k] = self.diis_error_matrices[k-1][:]
            self.diis_fock_matrices[k] = self.diis_fock_matrices[k-1][:]
            self.diis_energy[k] = self.diis_energy[k-1]
    
        # calculate error matrix
        error_mat  = numpy.dot(fock, dens)
        error_mat -= error_mat.T
    
    
        # put data in storage
        self.diis_error_matrices[0]  = error_mat
        self.diis_fock_matrices[0] = fock[:]
        self.diis_energy[0] = energy
    
        #determine wether you go EDIIS or CDIIS
        e_max=error_mat.max()
        e_min=error_mat.min()
        e_abs=max(abs(e_min),abs(e_max))
        print('e_max',e_max, 'e_min',e_min)
        if e_max < 10**-6 and e_min > -10**-6 : #if really small then dont do DIIS
            print('noDIIS')
            return fock,e_abs
        #EDIIS
        if e_max > 0.01 or e_min < -0.01 : #if big then do EDIIS
            print('EDIIS')
            #bmat
            bsize = min(iters, self.maxdiis)
            bmat = 1.0*numpy.ones((bsize+1,bsize+1))
            bmat[bsize, bsize] = 0
            for b1 in range(bsize):
                for b2 in range(bsize):
                    bmat[b1, b2] = numpy.trace(self.diis_error_matrices[b1].dot(self.diis_error_matrices[b2]))
            #rhs
            rhs = numpy.zeros(bsize+1)
            rhs[bsize] = 1
            for a in range(bsize):
                rhs[a]=self.diis_energy[a]
            while True:
                #solve
                C =  numpy.linalg.solve(bmat, rhs)
                #remove C_i<0
                if C[:-1].min() < 0:
                    i=numpy.argmin(C)
                    bmat=numpy.delete(bmat,i,0)
                    bmat=numpy.delete(bmat,i,1)
                    rhs=numpy.delete(rhs,i,0)
                    if len(rhs)==2: #no C_i<0 found
                        print('found no EDIIS')
                        return fock,e_abs
                    continue 
                break

            # form new interpolated diis fock matrix with non0 C_i
            for i, k in enumerate(C[:-1]):
                diis_fock += k*self.diis_fock_matrices[i]

            return diis_fock,e_abs
        #CDIIS
        else:   #if not big then do CDIIS
            print('CDIIS')
            self.diisiters+=1
            bsize = min(self.diisiters, self.maxdiis)
            bmat = -1.0*numpy.ones((bsize+1,bsize+1))
            rhs = numpy.zeros(bsize+1)
            bmat[bsize, bsize] = 0
            rhs[bsize] = -1
            for b1 in range(bsize):
                for b2 in range(bsize):
                    bmat[b1, b2] = numpy.trace(self.diis_error_matrices[b1].dot(self.diis_error_matrices[b2]))
            C =  numpy.linalg.solve(bmat, rhs)

            # form new interpolated diis fock matrix
            for i, k in enumerate(C[:-1]):
                diis_fock += k*self.diis_fock_matrices[i]

            return diis_fock,e_abs


def fcimaker(NORB, Ca, Cb, twomatrix,H,nml):
    MO_a=numpy.tensordot(Ca,numpy.tensordot(Ca,numpy.tensordot(Ca,numpy.tensordot(Ca,twomatrix,((0),(3))),((0),(2))),((0),(1))),((0),(0)))
    MO_b=numpy.tensordot(Cb,numpy.tensordot(Cb,numpy.tensordot(Cb,numpy.tensordot(Cb,twomatrix,((0),(3))),((0),(2))),((0),(1))),((0),(0)))
    H_MO=numpy.tensordot(Cb,numpy.tensordot(Cb,H,((0),(1))),((0),(0)))+numpy.tensordot(Cb,numpy.tensordot(Cb,H,((0),(1))),((0),(0)))
    fcidump = open(sys.argv[2], 'w')
    nml.write(fcidump)
    for I in range(1, NORB + 1):
        for J in range(1, I + 1):
            for K in range(1, I + 1):
                for L in range(1, K + 1):
                    if(I == K and J < L):
                            continue
                    fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(MO_a[I-1,J-1,K-1,L-1], I, J, K, L))
                    fcidump.write('\n')
    fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(0000000000000000, 0, 0, 0, 0))
    fcidump.write('\n')
    for I in range(1, NORB + 1):
        for J in range(1, I + 1):
            for K in range(1, I + 1):
                for L in range(1, K + 1):
                    if(I == K and J < L):
                            continue
                    fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(MO_b[I-1,J-1,K-1,L-1], I, J, K, L))
                    fcidump.write('\n')
    for I in range(1, NORB + 1):
        for J in range(1, I + 1):
            fcidump.write('{0:23.16E} {1:4d} {2:4d} {3:4d} {4:4d}'.format(H_MO[I-1,J-1], I, J, 0, 0))
            fcidump.write('\n')
    fcidump.write('{0:23.16E} {1:4d} {1:4d} {1:4d} {1:4d}'.format(E_nucc,0))
    fcidump.close()
    return

def init_all():
    with open(sys.argv[1],'r') as f:
        print('inputfile:',sys.argv[1])
        with open('tmpnml.tmp','w')as g:
            #find and copy nml
            while True:
                line = f.readline()
                g.write(line)
                if line.find('&END') != -1:
                    break
                if line.find(r'/') != -1:
                    break

        with open('tmpnml.tmp') as g:
            #read the nml
            nml = f90nml.read(g)
            NORB = nml['fci']['NORB']
            NELEC = nml['fci']['NELEC']
        os.remove('tmpnml.tmp')

        H = numpy.zeros((NORB, NORB))
        twomatrix = numpy.zeros((NORB, NORB, NORB, NORB))
        for my in range(NORB):
            for ny in range(my+1):
                for la in range(my+1):
                    for si in range(la+1):
                        if my==la and ny<si: continue
                        line = f.readline()
                        print(line) 
                        integral=numpy.float64(line.split()[0])
                        twomatrix[my, ny, la, si] = integral
                        twomatrix[ny, my, la, si] = integral
                        twomatrix[my, ny, si, la] = integral
                        twomatrix[ny, my, si, la] = integral
                        twomatrix[la, si, my, ny] = integral
                        twomatrix[si, la, my, ny] = integral
                        twomatrix[la, si, ny, my] = integral
                        twomatrix[si, la, ny, my] = integral
        for my in range(NORB):
            for ny in range(my+1):
                line= f.readline()
                integral = numpy.float64(line.split()[0])
                H[my,ny] = integral
                H[ny,my] = integral
        while True:
            line= f.readline()
            if int(line.split()[1]) == 0:
                E_nucc = numpy.float64(line.split()[0])
                break
    return(NORB, NELEC, E_nucc, H, twomatrix, nml)

def init_notall():
    with open(sys.argv[1],'r') as f:
        print('input=',sys.argv[1])
        with open('tmpnml.tmp','w')as g:
            #find and copy nml
            while True:
                line = f.readline()
                g.write(line)
                if line.find('&END') != -1:
                    break
                if line.find(r'/') != -1:
                    break

        with open('tmpnml.tmp') as g:
            #read the nml
            nml = f90nml.read(g)
            NORB = nml['fci']['NORB']
            NELEC = nml['fci']['NELEC']
        os.remove('tmpnml.tmp')


        H = numpy.zeros((NORB, NORB))
        twomatrix = numpy.zeros((NORB, NORB, NORB, NORB))
        while True:
            line=f.readline()
            if line == '':break
            integral = numpy.float64(line.split()[0])
            my = int(line.split()[1])-1
            ny = int(line.split()[2])-1
            la = int(line.split()[3])-1
            si = int(line.split()[4])-1
            if my == ny == la == si == -1:
                E_nucc = integral
            if la == si == -1 and my != -1 and ny != -1:
                H[my,ny] = integral
                H[ny,my] = integral
            elif my != -1 and ny != -1 and la != -1 and si != -1 :
                twomatrix[my, ny, la, si] = integral
                twomatrix[ny, my, la, si] = integral
                twomatrix[my, ny, si, la] = integral
                twomatrix[ny, my, si, la] = integral
                twomatrix[la, si, my, ny] = integral
                twomatrix[si, la, my, ny] = integral
                twomatrix[la, si, ny, my] = integral
                twomatrix[si, la, ny, my] = integral
    return(NORB, NELEC, E_nucc, H, twomatrix, nml)

def outsqr(title, mat, width=15):
        frmt = ''.join(['{: > ', str(width), '.', str(max(width - 7, 0)),
                        'f}'])
        ifrmt = ''.join(['{:^', str(width), 'd}'])
        headline = ''.join([ifrmt.format(i) for i in range(len(mat) + 1)])
        outline = '\n'.join([''.join([ifrmt.format(i + 1),
                            ''.join([frmt.format(val) for val in row])]) for i,
                            row in enumerate(mat)])
        print('\n'.join([title, headline, outline]))


class CCSD:
    def __init__(self,twomatrix):
        self.t1 = numpy.zeros((NORB,NORB))
        self.t2 = numpy.zeros((NORB, NORB, NORB, NORB))
        self.tau = numpy.zeros((NORB, NORB, NORB, NORB))
        self.twomatrix = twomatrix

    def A3(self,be,u,ga,v):
        A3 = [(self.twomatrix[i,u,j,v]*self.tau[be,i,ga,j])
                for i in range(NOCC)
                for j in range(NOCC)
                ]
        A3 = numpy.sum(A3)
        return A3

    def B3(self,be,u,ga,v):
        B3 = [(self.twomatrix[be,a,ga,b]*self.tau[be,i,ga,j])
                for a in range(NOCC,NORB)
                for b in range(NOCC,NORB)
                ]
        B3 = numpy.sum(B3)
        return B3

    def C1(self,i,u,be,i):
        C1 = [(self.twomatrix[i,u,be,a]*self.t1[a,i])
                for a in range(NOCC,NORB)
                ]
        C1 = numpy.sum(C1)
        return C1

    def C2(self,u,be,ga,v):
        C2 = [(self.twomatrix[be,a,i,u]*self.t2[ga,v,a,i])
                for i in range(NOCC)
                for a in range(NOCC,NORB)
                ]
        C2 = numpy.sum(C2)
        return C2

    def C3(self,u,be,ga,v):
        C3 = [(self.twomatrix[u,i,ga,a]*self.tau[be,i,a,v])
                for i in range(NOCC)
                for a in range(NOCC, NORB)
                ]
        C3 = numpy.sum(C3)
        return C3

    def D1(self,be,u,i,v):
        D1 = [(self.twomatrix[be,u,i,a]*self.t1[a,v])
                for a in range(NOCC, NORB)
                ]
        D1 = numpy.sum(D1)
        return D1

    def D2a(self,i,a,ga,v):
        D2a = [(self.twomatrix[j,b,i,a]*(2*self.t2[ga,v,b,j]-self.t2[b,v,ga,j]))
                for j in range(NOCC)
                for b in range(NOCC, NORB)
                ]
        D2a = numpy.sum(D2a)
        return D2a

    def D2b(self,i,a,ga,v):
        D2b = [(self.twomatrix[i,b,j,a]*self.t2[ga,v,b,j])
                for j in range(NOCC)
                for b in range(NOCC, NORB)
                ]
        D2b = numpy.sum(D2b)
        return D2b

    def D2c(self,i,a,ga,v):
        D2c = [(self.twomatrix[i,b,j,a]*self.t2[b,v,ga,j])
                for j in range(NOCC)
                for b in range(NOCC,NORB)
                ]
        D2c = numpy.sum(D2c)
        return D2c

    def D3(self,i,u,j,v):
        D3 = [(self.twomatrix[i,a,j,b]*self.tau[a,u,b,v])
                for a in range(NOCC,NORB)
                for b in range(NOCC, NORB)
                ]
        D3 = numpy.sum(D3)
        return D3

    def D3s(self,be,a,b,c):
        D3s = [(self.twomatrix[i,a,j,c]*self.tau[be,i,b,j])
                for i in range(NOCC)
                for j in range(NOCC)
                ]
        D3s = numpy.sum(D3s)
        return D3s

    def E1(self,i,u,j,v):
        E1 = [(self.twomatrix[i,u,j,a]*self.t1[a,v])
                for a in range(NOCC,NORB)
                ]
        E1 = numpy.sum(E1)
        return E1

    def E1s(self,i,u,j,v):
        E1s = [(self.twomatrix[i,u,j,a]*self.t1[a,v])
                for i in range(NOCC)
                ]
        E1s = numpy.sum(E1s)
        return E1s

    def E2a(self,i,u,ga,v):
        E2a = [(self.twomatrix[j,b,i,u]*(2*self.t2[ga,v,b,j]-self.t2[b,v,ga,j]))
                for j in range(NOCC)
                for b in range(NOCC,NORB)
                ]
        E2a = numpy.sum(E2a)
        return E2a

    def E2b(self,i,u,ga,v):
        E2b = [(self.twomatrix[i,b,j,u]*self.t2[ga,v,b,j])
                for j in range(NOCC)
                for b in range(NOCC,NORB)
                ]
        E2b = numpy.sum(E2b)
        return E2b

    def E2c(self,i,u,ga,v):
        E2c = [(self.twomatrix[i,b,j,u]*self.t2[b,v,ga,j])
                for j in range(NOCC)
                for b in range(NOCC,NORB)
                ]
        E2c = numpy.sum(E2c)
        return E2c

    def F11(self,be,b,i,v):
        F11 = [(self.twomatrix[be,b,i,a]*self.t1[a,v])
                for a in range(NOCC,NORB)
                ]
        F11 = numpy.sum(F11)
        return F11

    def F12(self,i,b,be,v):
        F12 = [(self.twomatrix[i,b,be,a]*self.t1[a,v])
                for a in range(NOCC,NORB)
                ]
        F12 = numpy.sum(F12)
        return F12

    def F1s(self,be,a,b,c):
        F1s = [(self.twomatrix[be,a,i,c]*self.t1[b,i])
                for a in range(NOCC,NORB)
                ]
        F1s = numpy.sum(F1s)
        return F1s

    def F2a(self,be,u,i,v):
        F2a = [(self.twomatrix[be,a,a,u]*(2*self.t2[a,u,b,i]-self.t2[b,u,a,i]))
                for i in range(NOCC)
                for b in range(NOCC,NORB)
                ]
        F2a = numpy.sum(F2a)
        return F2a

    def F3(self,be,u,i,v):
        F3 = [(self.twomatrix[be,a,i,b]*self.tau[a,u,b,v])
                for a in range(NOCC,NORB)
                for b in range(NOCC,NORB)
                ]
        F3 = numpy.sum(F3)
        return F3


                






        




        









if __name__ == '__main__':
    main()
